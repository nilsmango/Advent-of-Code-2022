<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>BaseFile</key>
	<string>Chapters/Chapter1.playgroundchapter/Pages/Template.playgroundpage/main.swift</string>
	<key>Diffs</key>
	<array>
		<dict>
			<key>ModifiedContent</key>
			<string>import Foundation

let input = load(file: "input07")

private enum Line {
    case cd(String)
    case ls
    case file(Int)
    case dir(String)
    
    init(_ str: String) {
        let parts = str.components(separatedBy: " ")
        if parts[0] == "$" {
            // command
            if parts[1] == "cd" {
                self = .cd(parts[2])
            } else {
                assert(parts[1] == "ls")
                self = .ls
            }
        } else {
            // output
            if parts[0] == "dir" {
                self = .dir(parts[1])
            } else if let size = Int(parts[0]) {
                self = .file(size)
            } else {
//                fatalError()
                self = .file(0)
            }
        }
    }
}

private struct Directory: Hashable, CustomStringConvertible {
    private let components: [String]
    
    init(_ components: [String] = []) {
        self.components = components
    }
    
    var depth: Int { components.count }
    
    static let root = Directory(["^"])
    
    func chdir(to dir: String) -&gt; Directory {
        if dir == ".." {
            assert(components.count &gt; 1)
            return Directory(components.dropLast())
        } else if dir == "/" {
            return Self.root
        } else {
            return Directory(components + [dir])
        }
    }
    
    var description: String {
        components.joined(separator: "/")
    }
}


    private let lines: [Line]
    private var totals: [Directory: Int]?
    
    
lines = input!.components(separatedBy: .newlines).map { Line($0) }
    
    
    func part1() -&gt; Int {
        var totals = diskUsage()
        
        return totals.values
            .filter { $0 &lt;= 100000 }
            .reduce(0, +)
    }
    
//    func part2() -&gt; Int {
//        let diskSize = 70000000
//        let requiredFree = 30000000
//        
//        let totals = self.totals ?? diskUsage()
//        
//        let rootSize = totals[.root]!
//        let currentFree = diskSize - rootSize
//        
//        return totals.values.sorted(by: &lt;).filter { currentFree + $0 &gt;= requiredFree }.first!
//    }
    
    private func diskUsage() -&gt; [Directory: Int] {
        // get individual dir sizes
        var sizes = [Directory: Int]()
        var cwd = Directory()
        for line in lines {
            switch line {
            case .cd(let dir):
                cwd = cwd.chdir(to: dir)
            case .ls:
                continue
            case .dir(let dir):
                // make sure to create a record for each directory in case it contains no files
                sizes[cwd.chdir(to: dir)] = 0
            case .file(let size):
                sizes[cwd, default: 0] += size
            }
        }
        
        // sum sizes from the bottom up
        var totals = [Directory: Int]()
        for (dir, size) in sizes.sorted(by: { $0.key.depth &gt; $1.key.depth }) {
            totals[dir, default: 0] += size
            
            if dir.depth &gt; 1 {
                let parent = dir.chdir(to: "..")
                totals[parent, default: 0] += totals[dir]!
            }
        }
        
        return totals
    }

print(part1())
print(diskUsage())
</string>
			<key>ModifiedRange</key>
			<string>{0, 3221}</string>
			<key>OriginalContent</key>
			<string>
</string>
			<key>OriginalRange</key>
			<string>{0, 1}</string>
		</dict>
	</array>
	<key>FormatVersion</key>
	<integer>2</integer>
</dict>
</plist>
